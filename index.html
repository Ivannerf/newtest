<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL GLB Uploader with HDRI and Fixed Camera</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #fileInput {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background-color: white;
            border-radius: 5px;
            z-index: 1;
        }
        #arButton {
            position: absolute;
            top: 60px;
            left: 10px;
            padding: 10px;
            background-color: #00f;
            color: white;
            border-radius: 5px;
            z-index: 1;
        }
    </style>
</head>
<body>
    <input type="file" id="fileInput" accept=".glb" />
    <button id="arButton">Checking AR Support...</button> <!-- AR Button -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script> <!-- DRACOLoader script -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const fileInput = document.getElementById('fileInput');
        const arButton = document.getElementById('arButton');
        let scene, camera, renderer, model, hdrTexture;
        let isMouseDown = false, lastMouseX = 0, lastMouseY = 0;

        // Check for WebXR support
        function checkWebXRSupport() {
            if (navigator.xr) {
                arButton.textContent = 'Enter AR';  // Change button text if WebXR is supported
                arButton.onclick = () => {
                    startARSession();
                };
            } else {
                arButton.textContent = 'AR Not Available';  // Change button text if WebXR is not supported
                arButton.disabled = true;  // Disable the button if AR is not available
            }
        }

        // Start AR session
        function startARSession() {
            if (navigator.xr) {
                navigator.xr.requestSession('immersive-ar').then((session) => {
                    xrSession = session;
                    // Handle the AR session here
                    console.log("AR session started");
                    // Your AR rendering logic can go here
                }).catch((error) => {
                    console.error("Failed to start AR session", error);
                });
            }
        }

        // Initialize the scene
        function init() {
            console.log("Initializing scene...");

            // Create scene, camera, and renderer
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Load HDRI background for lighting
            const hdrLoader = new THREE.RGBELoader();
            hdrLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/equirectangular/royal_esplanade_1k.hdr', function (texture) {
                hdrTexture = texture;
                hdrTexture.mapping = THREE.EquirectangularReflectionMapping;
                scene.background = hdrTexture;
                scene.environment = hdrTexture;  // Set the HDRI as scene environment
                console.log("HDRI loaded successfully.");
                animate(); // Start the animation loop after HDRI is loaded
            });

            // Camera setup - fixed camera position
            camera.position.set(0, 1, 3);  // Set camera slightly above and a bit back from the object
            camera.lookAt(0, 0, 0);  // Ensure the camera is looking at the center of the scene

            // Add ambient light to make the model visible
            const ambientLight = new THREE.AmbientLight(0x404040, 1);  // Ambient light to brighten the scene
            scene.add(ambientLight);

            // Add directional light to simulate sunlight
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5).normalize();
            scene.add(directionalLight);

            console.log("Scene initialized with HDRI, camera, ambient light, and directional light.");
        }

        // Load a GLB model with DRACO support
        function loadGLB(url) {
            console.log("Loading GLB model from URL:", url);

            // Setup the DRACOLoader
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/draco/'); // Path for Draco decoder

            // Setup the GLTFLoader with DRACOLoader
            const loader = new THREE.GLTFLoader();
            loader.setDRACOLoader(dracoLoader);

            loader.load(url, (gltf) => {
                console.log("GLB model loaded:", gltf);

                // Remove any previously loaded model
                if (model) {
                    scene.remove(model);
                    console.log("Removed previous model from scene.");
                }

                // Add new model
                model = gltf.scene;
                scene.add(model);

                // Adjust model position and scale
                model.scale.set(1, 1, 1);

                // Center the model at the world origin (0, 0, 0)
                const box = new THREE.Box3().setFromObject(model);
                const center = new THREE.Vector3();
                box.getCenter(center); // Get the center of the model's bounding box
                model.position.sub(center); // Offset model to make its center at (0, 0, 0)

                // Now, adjust the camera position dynamically based on the model size
                const size = new THREE.Vector3();
                box.getSize(size);

                // Calculate the distance from the camera to the model based on its size
                const distance = Math.max(size.x, size.y, size.z) * 2;  // Adjusted to ensure it's a little farther away
                camera.position.set(0, 0, distance);  // Set the camera position based on size
                camera.lookAt(center);  // Ensure the camera is always looking at the center of the model

                console.log("Model added to scene.");
            }, undefined, (error) => {
                console.error("Error loading GLB:", error);
            });
        }

        // Animation loop (rotate the object based on mouse interaction)
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Window resize handling
        window.addEventListener('resize', () => {
            console.log("Window resized.");
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Handle file upload
        fileInput.addEventListener('change', (event) => {
            console.log("File input changed.");
            const file = event.target.files[0];
            if (file) {
                console.log("File selected:", file.name);
                if (file.name.endsWith('.glb')) {
                    const url = URL.createObjectURL(file);
                    console.log("Object URL created:", url);
                    loadGLB(url);
                } else {
                    console.log("Invalid file type. Please upload a .glb file.");
                    alert('Please upload a valid .glb file');
                }
            } else {
                console.log("No file selected.");
            }
        });

        // Check for WebXR support when the page loads
        checkWebXRSupport();

        // Initialize the scene
        init();
    </script>
</body>
</html>
